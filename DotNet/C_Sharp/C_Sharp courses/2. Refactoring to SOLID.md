Based on the `Refactoring to SOLID C# Code` course on pluralsight

---
Aside from the basic SOLID principles.
Use `decimal` instead of `float` for prices to avoid rounding error.

Avoid static classes as we can't do dependency injection with those. Because in C# static class constructor does not accept any parameters.

Declare a variable near where you would use it, not at very top to avoid cognitive overload.

Make sure there's no mixed levels of abstractions, like high level business code with low level implementation details put together. 

If we have an instance of the class `Kitchen`, it's NOT the `Kitchen`'s responsibility to get itself from some db, `kitchen.GetCustomerKitchen(kitchenId, userName)`. This violates the single responsibility principle. Use `repository` or directly with `dbcontext`.

---
#### Applying Single Principle Responsibility

When a class accepts a lot of primitives, we could put them into a separate type like below. 

Here we introduced a `PriceRequest` struct for bundling all the primitives. Then we call the original function inside our new `CalculatePrice` with `PricrRequest`.

![[Pasted image 20240715102610.png]]

We can then call this new code with object initialiser syntax.
![[Pasted image 20240715102807.png]]

Once we are done, we can now replace the original `CalculatePrice()` by updating the parameters to take in a `PriceRequest`.

---

The `CalculatePrice()` returns `0|0|0`, a string of prices. We can refactor it such that it returns 3 decimals instead, we can define a record for the return value.
```csharp
public record PriceGroup(decimal Subtotal, decimal SubtotalFalt, decimal SubtotalPlus);
```

---

We can group primitive variables into a record struct inside `CalculatePrice()`.
```csharp
public record struct Subtotals() {
	public decimal Value { get; set; }
	public decimal Flat { get; set; }
	public decimal Plus { get; set; }
}
```

---

Within `CalculatePrice()`, we have numerous places where we fetch something from a sqlite db. Extract this out to a method initially.


#### Applying Dependency Injection and Interface Segregation Principle












