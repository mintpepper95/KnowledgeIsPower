From `SOLID Principles for C# Developers` pluralsight


Do PDD - write your code in the simplest way you know. Avoid applying SOLID as premature optimisation. If code turns out to be a pain to work, then apply SOLID.

---
### Single Responsibility Principle
Loose coupling, and separation of concerns - high level code should have no knowledge about low level implementation details

Cohesion - How related how closely related elements of classes or modules are to one another. Higher responsibility -> Less cohesion.

Coupling - relationship between classes.

#### Case study - Rating engine for rating insurance policy

Rating engine has a lot of responsibilities.
![[Pasted image 20240713184607.png]]

It also contains lots of business rules, validations, age calculations (age calculation is very low level detail ) etc
![[Pasted image 20240713184706.png]]

##### Refactoring
We can identify different responsibilities, like validations, age calculations, persistence, logging and encoding, and put them into separate classes and inject them.


### Open closed principle
Open for extension, closed for modification.

#### Open to extension
* Easy to add new behaviour
#### Closed to modification
* Changes to existing code logic is not required much, as the less we are likely to change existing logic, the less we are likely to introduce bugs and break things.

We want to balance abstraction and concreteness, as abstraction adds complexity.

Extreme case - Very closed
![[Pasted image 20240713190232.png]]
When you new an object, you're making the code concrete. The code is fine, until it isn't.

Extreme case - very open
![[Pasted image 20240713190336.png|500]]

When writing code, we can start out being concrete, and wait and see how the application evolves overtime before making changes. E.g. By the 3rd time you have to modify the same area, consider refactoring to apply OCP.


#### What are the 3 typical approaches to OCP
* Introduce new parameters to a function to change its behaviour
* Use inheritance, creating a new child class that inherits a type
* Dependency injection

![[Pasted image 20240713190735.png|400]]

* Parameter based extension
	Introduce new parameter for hard coded values
 ![[Pasted image 20240713190832.png]]
* Inheritance based extension
	Mark parent class method as virtual so we can override in child class
![[Pasted image 20240713191016.png|400]]
* Injection
	Extract out logic and dep inject it as another class
 ![[Pasted image 20240713191045.png|400]]

We should prefer implementing new features in new classes.
This allows us to add functionalities without increasing complexity of existing system.


Currently inside Rating engine, we load the policy first and then there's a switch statement to determine policy type and the logic.

If we want to add another policy we would have to add another case in the switch.
```csharp
public class RatingEngine {
        public decimal Rating { get; set; }
        
        public void Rate() {
            Console.WriteLine("Starting rate.");

            Console.WriteLine("Loading policy.");

            // load policy - open file policy.json
            string policyJson = File.ReadAllText("policy.json");

            var policy = JsonConvert.DeserializeObject<Policy>(policyJson,
                new StringEnumConverter());

            switch (policy.Type)
            {
                case PolicyType.Auto:
                    Console.WriteLine("Rating AUTO policy...");
                    Console.WriteLine("Validating policy.");
                    if (String.IsNullOrEmpty(policy.Make))
                    {
                        Console.WriteLine("Auto policy must specify Make");
                        return;
                    }
                    if (policy.Make == "BMW")
                    {
                        if (policy.Deductible < 500)
                        {
                            Rating = 1000m;
                        }
                        Rating = 900m;
                    }
                    break;
                case PolicyType.Land:
	                // ...
	                }
	            }
	        }
	    }
	}
                
```

We can extract the logic for every Policy and move that logic into its own type. Then we don't have to touch the logic here.

In this case, we can come up with different raters, like AutoPolicyRater, or LandPolicyRater etc, where we encapsulate the rating logic.

We can then create a RaterFactory for Creating different raters.
The switch statement has been moved to the factory.
Now RatingEngine is no longer responsible for determining which type to use what logic. Now the factory is responsible for it.
![[Pasted image 20240713192201.png]]

The RatingEngine will now look like this
![[Pasted image 20240713192402.png]]

A new policy rater would look like below
Rate method is open to extension ( creating new class that derives Rater ) and closed for modification ( we don't need to change existing Rater classes when implementing a new Rater ) 
![[Pasted image 20240713192543.png]]

We can make apply OCP to factory as well via reflection.
If we don't find a matching class name, we just return null.
This completely eliminates the switch statement.
![[Pasted image 20240713192800.png]]


#### Applying OCP to packages/libraries
Nuget packages are closed for modifications from consumers.
* Consumers can't change package contents
* When packages authors update package, they should not break existing consumers.
* Packages should be open to extension - so consumers can extend the package to suit their own needs, usually via interfaces provided by the package.


### Liskov Substitution Principle
Subtypes must be substitutable for their base types

Inheritance - when `yy` is a `xx` , e.g. an `eagle` is a `bird`.

Property - when `zz` has a `ww`, e.g. a `address` has a `city`.

LSP states is...a relationship is insufficient, should be replaced with is...substitute for...

A rectangle has 4 sides and 4 right angles.

A square has 4 equal sides and 4 right angles.

Per geometry, a square is a rectangle.

However, if we treat Square as a subtype of Rectangle, we need to enforce the rule that width and height are the same for Square inside its setters.

Problem arises when we have some code that we expect to work with rectangle, but we used square. 

If the Square is passed in from somewhere else, then it would be hard to detect this anomaly.

![[Pasted image 20240713194232.png]]

Square has the invariant - 4 sides must be equal
Rectangle has the invariant - sides are independent

This design breaks rectangle's invariant and therefore violates LSP.

One solution is to eliminate square class like below, or we can have Square as a separate class not related to Rectangle.
![[Pasted image 20240713194456.png]]


#### Case - detecting LSP violations

If you are checking the type of a variable with `is` or `as` inside code that should be polymorphic ( code that works with any subtype ), that's a clue of a violation.
Null checks
`NotImplementedException`, meaning the class that throws it does not yet support it. Either not substitutable or we have to implement it. So this derived class is NOT substitutable for the base class.

Here is a violation, the actual type of the employee should NOT be important in the logic.
![[Pasted image 20240713194810.png]]

Fix 1: To fix this, we need to make sure each type implements Print in its own class.
However becareful not to violate the single responsibility principle.
![[Pasted image 20240713194939.png]]

Fix 2: Or we can adjust the helper method so it works with any kind of employee.
We have now consolidated all employee type checks to one place.
![[Pasted image 20240713195045.png]]


Checking for null is the same behaviour as checking for type.
Meaning that we have different behaviours depending on whether the instance is null or not like below. LSP violation.
![[Pasted image 20240713195146.png]]


Take away - Don't ask instances for their types, and then conditionally perform different actions. Instead encapsulate that logic in the type itself.

We can minimize null checks for guard clauses, nullables, or use exceptions to prevent null values from reaching primary logic in the code...

Make sure to fully implement interface


Case study - this violates LSP as it treats null differently
![[Pasted image 20240713195935.png]]

What we can do is introduce an unknown policy rater and move the logic to there. And then modify the factory to return this if we can't find a matching rater to a policy instead of returning null.

Null object pattern
![[Pasted image 20240713200013.png]]
![[Pasted image 20240713200114.png]]



### Interface segregation principle
Prefer small, cohesive interfaces to larger fatter ones.

An interface is defined as whatever can be accessible by consumer working with instance of that type.

![[Pasted image 20240713200744.png]]
Imagine inheriting an gigantic interface, recall not implementing some method is breaking LSP, which isn't ideal.

Violating ISP increase coupling as consumers will depend on things they don't use. Makes it harder to change/test.

#### Detecting ISP violations
* Look for large interfaces
* See if there are any `NotImplementedException` or if any consumer using a small subset of a larger interface

We can split up interfaces.
Since C# support multiple interface inheritance, we can replace original fat interface with all new smaller interfaces when refactoring legacy code. Of course, this only works when you own the interface.

#### Fixing ISP violations
Larger interfaces makes it harder to implement, thus ISP is related to LSP. ISP relies on SRP and cohesion.

Use pain driven development, don't implement pre-maturely.

* Break up larger interfaces into smaller ones
* For larger interfaces you don't control, create small cohesive interfaces following adaptor design pattern
* Use clients to define interfaces, so all interface properties are used
* Interfaces should be declared where consumer and implementations can access it

#### Case study
We now have a `IRatingContext` class property for the rating engine.
Now every line calls methods on the context property.

![[Pasted image 20240713202319.png]]
![[Pasted image 20240713202347.png]]
![[Pasted image 20240713202407.png]]

Fat interface - to fix this, breakdown into smaller interfaces
![[Pasted image 20240713202449.png]]



### Dependency Inversion











